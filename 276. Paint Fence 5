class Solution(object):
    def numWays(self, n, k):
        """
        :type n: int
        :type k: int
        :rtype: int
        https://blog.csdn.net/qq508618087/article/details/50863010
        """
        if n == 0 or k == 0:
            return 0
        dp_1 = [0]*(n+1)
        dp_2 = [0]*(n+1)
        dp_2[1] = k
        for i in range(2, n+1):
            dp_1[i] = dp_2[i-1]
            dp_2[i] = (dp_1[i-1] + dp_2[i-1])*(k-1)
        return dp_1[-1] + dp_2[-1]
    # 因为我们有两种可能性，与前一刻相同或者与前一刻不同。
    # 我们需要维护两个dp
    # 这是一个双重dp的问题，对于第i个柱子染什么颜色我们要考虑是否和之前染一样的颜色

# 1. 如果和i-1染一样的颜色，那么第i-1个柱子就不能和第i-2染一样的颜色

# 2. 如果和第i-1染不一样的颜色，那么第i个柱子的染色方案数即为 sum(i-1) * (k-1)

# 也就是为了得到第i个柱子的染色方案，我们需要利用之前的两个状态，一个是i-1和i-2染一样颜色的方案数，另一个是i-1和i-2染不一样颜色的方案数，这样我们需要两个dp数组dp1, dp2分别记录对应的状态

# 然后考虑两个dp数组的递推公式：

# dp1[i] = dp2[i-1]，这个表示如果i和i-1染一样的色，那么染色方案为dp2[i-1]

# dp2[i] = (dp1[i-1] + dp2[i-1]) * (k-1)，表示i和i-1染不一样染色，对于第i-1的每一种染色方案，我们有k-1种颜色可选
